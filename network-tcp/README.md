# TCP灵魂之问

先扫盲：

frame对应mac，packet对应ip，datagram对应udp，segment对应tcp，message对应app。

上问题：

1. 请画出三次握手和四次挥手的示意图
2. 为什么连接的时候是三次握手？
3. 什么是半连接队列？
4. ISN(Initial Sequence Number)是固定的吗？
5. 三次握手过程中可以携带数据吗？
6. 如果第三次握手丢失了，客户端服务端会如何处理？
7. SYN攻击是什么？
8. 挥手为什么需要四次？
9. 四次挥手释放连接时，等待2MSL的意义?

<img src="https://lskreno.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1.jpg" style="zoom: 50%;" />

<img src="https://lskreno.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2.jpg" style="zoom: 50%;" />

这篇文章的思维导图:

![img](https://pic3.zhimg.com/80/v2-dbbdb2ba824a121f18a66059ac0b5ac2_720w.jpg)

TCP 作为传输层的协议，是一个软件工程师素养的体现，也是面试中经常被问到的知识点。在此，我将 TCP 核心的一些问题梳理了一下，希望能帮到各位。

随着对网络的理解深入，明白TCP报文是交由IP网络来负责运输，IP网络并不能保证TCP报文到达目的地，既然IP网络是指望不上了，那TCP就自力更生吧，TCP必须依赖自身的努力来保证数据传输的可靠。

TCP看似复杂，其实可以归纳为以下5种报文：
（1）SYN
（2）Data（唯一携带用户数据）
（3）FIN
（4）Reset
（5）ACK

其中1、2、3分别为**建立连接、数据传输、断开连接**，这**三种报文对方接收到一定要ACK确认**，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在**超时时间内不确认，发送方会一直重传**，直到对方确认为止、**或到达重传上限次数而Reset连接。**

4、5 为**重置连接报文、确认ACK报文**，这两种报文对方接收到要ACK确认吧？不需要！自然发送方也不会重传这2种类型的报文。

**为何Reset报文不需要ACK确认?**

因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。

如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。

如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。

**为何ACK报文不需要ACK确认?**

这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。

所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。

有同学会说，按照这么说，TCP连接应该是四次消息交互啊。

**1.A 发送SYN 报文给B，这是第一次报文交互。**

**2. B发送ACK确认A的SYN报文，这是第二次报文交互**

**3. B发送自己的SYN报文给A，这是第三次报文交互**

**4. A需要ACK确认B的SYN报文，这是第四次报文交互**

以上的演绎没有问题，但是报文2、3为何要分开发送呢？增加了延迟不说，同时还白白浪费了网络的带宽，完全可以将报文2、3合并起来，不就是在报文2的ACK状态位的位置置“1”就结了吗？

这就是三次消息交互的由来！



## 001. 能不能说一说 TCP 和 UDP 的区别？

首先概括一下基本的区别:

**TCP是一个面向连接的、可靠的、基于字节流的传输层协议。**

而**UDP是一个面向无连接的传输层协议。**(就这么简单，其它TCP的特性也就没有了)。

具体来分析，和 UDP 相比，TCP 有三大核心特性:

1. **面向连接**。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. **可靠性**。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。

TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。

当意识到**丢包了**或者**网络环境不佳**，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。

相应的，UDP 就是无状态, 不可控的。

1. **面向字节流**。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

“TCP是一种流模式的协议，UDP是一种数据报模式的协议”，这句话相信大家对这句话已经耳熟能详~但是，“流模式”与“数据包模式”在编程的时候有什么区别呢?以下是我的理解，仅供参考!

1、TCP

打个比方比喻TCP，你家里有个蓄水池，你可以里面倒水，蓄水池上有个龙头，你可以通过龙头将水池里的水放出来，然后用各种各样的容器装(杯子、矿泉水瓶、锅碗瓢盆)接水。

上面的例子中，往水池里倒几次水和接几次水是没有必然联系的，也就是说你可以只倒一次水，然后分10次接完。另外，水池里的水接多少就会少多少;往里面倒多少水，就会增加多少水，但是不能超过水池的容量，多出的水会溢出。

结合TCP的概念，**水池**就好比**接收缓存**，**倒水**就相当于**发送数据**，**接水**就相当于**读取数据**。好比你通过TCP连接给另一端发送数据，你只调用了一次 write，发送了100个字节，但是对方可以分10次收完，每次10个字节;你也可以调用10次write，每次10个字节，但是对方可以一次就收完。 (假设数据都能到达)但是，**你发送的数据量不能大于对方的接收缓存(流量控制)**，如果你硬是要发送过量数据，则**对方的缓存满了就会把多出的数据丢弃。**

2、UDP

UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UPD是基于报文的，在接收的时候，每次最多只能读取一个 报文，**报文和报文是不会合并的，**如果缓冲区小于报文长度，则多出的部分会被丢弃。也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。

3、为什么

其实，这种不同是由TCP和UDP的特性决定的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的(劫持什么的不考虑)，因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。

而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一 个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一 起，这样的数据是没有意义的。

两个协议其他区别

**TCP(Transmission Control Protocol)传输控制协议：**

该协议主要用于在主机间建立一个虚拟连接，以实现高可靠性的数据包交换。IP协议可以进行IP数据包的分割和组装，但是通过IP协议并不能清楚地了 解到数据包是否顺利地发送给目标计算机。而使用TCP协议就不同了，在该协议传输模式中在将数据包成功发送给目标计算机后，TCP会要求发送一个确认;如 果在某个时限内没有收到确认，那么TCP将重新发送数据包。另外，在传输的过程中，如果接收到无序、丢失以及被破坏的数据包，TCP还可以负责恢复。

传输控制协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，通常由IETF的RFC793说明。在简化的计算机网络OSI模型中，它完成运输层所指定的功能。

**UDP (User Datagram Protocol) 用户数据报协议：**

用户数据报协议(UDP)是 ISO参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 UDP 协议基本上是 IP 协议与上层协议的接口。 UDP协议适用端口分辨运行在同一台设备上的多个应用程序。

由于大多数网络应用程序都在同一台机器上运行，计算机上必须能够确保目的地机器上的软件程序能从源地址机器处获得数据包，以及源计算机能收到正确的回复。这是通过使用UDP 的“端口号”完成的。

区别：

1、基于连接与无连接

TCP---传输控制协议提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。

每个数据包的传输过程是：先建立链路、数据传输、然后清除链路。数据包不包含目的地址。受端和发端不但顺序一致，而且内容相同。它的可靠性高。

UDP---用户数据报协议是面向无连接的，每个数据包都有完整的源、目的地址及分组编号，各自在网络中独立传输，传输中不管其顺序，数据到达收端后再进行排序组装，遇有丢失、差错和失序等情况，通过请求重发来解决。它的效率比较高。

是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。

2、对系统资源的要求(TCP较多，UDP少)

3、UDP程序结构较简单

4、流模式与数据报模式

5、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证

6、TCP是面可靠的字节流服务 ，UDP 并不提供对 IP协议的可靠机制、流量控制以及错误恢复功能等。
点赞 



## 002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？

### 恋爱模拟

以谈恋爱为例，两个人能够在一起最重要的事情是首先确认各自**爱**和**被爱**的能力。接下来我们以此来模拟三次握手的过程。

第一次:

男: **我爱你。**

女方收到。

由此证明男方拥有爱的能力。

第二次:

女: **我收到了你的爱，我也爱你。**

男方收到。

OK，现在的情况说明，女方拥有爱和被爱的能力。

第三次:

男: **我收到了你的爱。**

女方收到。

现在能够保证男方具备被爱的能力。

由此完整地确认了双方爱和被爱的能力，两人开始一段甜蜜的爱情。

### 真实握手

当然刚刚那段属于扯淡，不代表本人价值观，目的是让大家理解整个握手过程的意义，因为两个过程非常相似。对应到 TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程:



<img src="https://pic3.zhimg.com/80/v2-859c73d767b7211e7f094ecaa4938fde_720w.jpg" alt="img" style="zoom: 80%;" />



从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。

然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。

服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。

之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。

另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则:

> 凡是需要对端确认的，一定消耗TCP报文的序列号。

SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。



TCP作为一种可靠传输控制协议，其**核心思想**：既要保证数据可靠传输，又要提高传输的效率，而用**三次恰恰可以满足以上两方面的需求！**

**TCP可靠传输的精髓：**TCP连接的一方A，由操作系统动态随机选取一个**32位长的序列号（Initial Sequence Number）**，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的**每个字节的数据进行编号**，1001，1002，1003..，**并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的**，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。

同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003..，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。

**一句话概括，TCP连接握手，握的是啥？**
**通信双方数据原点的序列号！**

以此核心思想我们来分析**二、三、四次握手**的过程。

A<------->B**四次握手**的过程：
**1.1** A发送同步信号SYN+A's Initial sequence number
**1.2** B确认收到A的同步信号，并记录A's ISN到本地，命名B'sACK sequence number
**1.3** B发送同步信号SYN+B's Initial sequence number
**1.4** A确认收到B的同步信号，并记录B'sISN到本地，命名A's ACK sequence number

很显然1.2和1.3这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。

A<------->B**二次握手**的过程：
**2.1** A发送同步信号**SYN** + **A's Initial sequence number**
**2.2** B发送同步信号**SYN** + **B's Initial sequence number** + **B's ACK sequence number**

这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。
于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP segment必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。

有童鞋会说，**如果A发给B的确认丢了**，该如何？
A会超时重传这个ACK吗？不会！**TCP不会为没有数据的ACK超时重传。**
那该如何是好？**B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止**

------

**丢包补充：**
第一个包，即A发给B的SYN中途被丢，没有到达B ，A会周期性超时重传，直到收到B的确认
第二个包，即B发给A的SYN+ACK中途被丢，没有到达A，B会周期性超时重传，直到收到A的确认
第三个包，即A发给B的ACK中途被丢，没有到达B，A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态：

**a.** 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接也为Established状态，双向可以发包。
**b.** 假定此时A有数据发送，B收到A的Data+ACK，自然会切换为established状态，并接受A的Data。
**c.** 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN+ACK，直到收到A的确认才可以发送数据。


**TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的。**

所以这样就有一个问题：

**这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？**——这就需要独一无二的 **ISN（初始序列号）机制。**

当一个新连接建立时，`初始序列号（ initial sequence number ISN）生成器`会生成一个新的32位的 ISN。

这个生成器会用一个32位长的时钟，差不多`4µs` 增长一次，因此 ISN 会在大约 4.55 小时循环一次

（`2^32`位的计数器，需要`2^32*4 µs`才能自增完，除以1小时共有多少µs便可算出`2^32*4 /(1*60*60*1000*1000)=4.772185884` ）

而一个报文段在网络中并不会比**最大报文段寿命（Maximum Segment Lifetime (MSL)** ，默认使用**2分钟**）长，MSL 比4.55小时要短，所以我们可以认为 ISN 会是唯一的。

发送方与接收方都会有自己的 ISN （下面的例子中就是 X 与 Y）来做双方互发通信，具体的描述如下：

> 1) A --> B  SYN my sequence number is X 
>
> 2) A <-- B  ACK your sequence number is X 
>
> 3) A <-- B  SYN my sequence number is Y 
>
> 4) A --> B  ACK your sequence number is Y

2与3都是 **B 发送给 A，因此可以合并在一起**，因此成为`three way (or three message) handshake`（其实翻译为三步握手，或者是三次通信握手更为准确）

因此最终可以得出，三次握手是必须的。



**三次握手的原则设计**是**防止旧复用链接的初始化导致问题**，为了解决此问题，我们设计了`reset`这个特别的控制信号来处理。

如果**接收中的 TCP 在一个未同步状态如 `SYN-SENT, SYN-RECEIVED`，它会返回 `reset` 给对方。**

如果 **TCP 是同步状态中如`(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT)`，他会终止此连接并通知用户。**

看起来有点绕，我们举个图例看看：

```text
     TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...

  3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED

  4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED

  5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN

  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED

                    Recovery from Old Duplicate SYN
```

这是 复用连接时，旧包比新连接的包先到B端的例子。

- 3中，一个旧的重复的 `SYN`到达 `B`。 
- 4中， `B`分别不出是否旧的，照样子正常回包。
- 5中，`A`检测到 `B` 返回的`ACK`不正确，所以返回 `RST(reset)`
- 6中，`B`接收到  `RST(reset)`信号，于是变成 `LISTEN` 状态。
- 7中，新连接正常的 `SYN`终于到达了，三次握手正常进行。

这种是简化的情况，但是可以看出 TCP 是如何处理复用旧链接的包到达的。



### 为什么不是两次？

根本原因: 无法确认客户端的接收能力。

分析如下:

如果是两次，你现在发了 SYN 报文想握手，但是这个包**滞留**在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。

看似没有问题，但是连接关闭后，如果这个**滞留**在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认**建立连接**，但是现在客户端已经断开了。

看到问题的吧，这就带来了连接资源的浪费。

### 为什么不是四次？

三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？

当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

### 三次握手过程中可以携带数据么？

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

### 同时打开会怎样？

如果双方同时发 SYN报文，状态变化会是怎样的呢？

这是一个可能会发生的情况。

状态变迁如下:



<img src="https://pic1.zhimg.com/80/v2-c99d5f1fe9d483073ff358adab8e4e24_720w.jpg" alt="img" style="zoom:67%;" />



在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了!

发完SYN，两者的状态都变为SYN-SENT。

在各自收到对方的SYN后，两者状态都变为SYN-REVD。

接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。

这就是同时打开情况下的状态变迁。

## 003: 说说 TCP 四次挥手的过程

### 过程拆解



<img src="https://pic4.zhimg.com/80/v2-3943c6b3b43a16659578334e18c30003_720w.jpg" alt="img" style="zoom: 67%;" />

刚开始双方处于ESTABLISHED状态。

客户端要断开了，向服务器发送 FIN 报文。

发送后客户端变成了FIN-WAIT-1状态。注意, 这时候**客户端同时也变成了**half-close(半关闭)状态，即**无法向服务端发送报文，只能接收。**

服务端接收后向客户端确认，变成了CLOSED-WAIT状态。

客户端接收到了服务端的确认，变成了FIN-WAIT2状态。

随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，

客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。

注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 **2 个 MSL(Maximum Segment Lifetime，报文最大生存时间)**, 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。

### 等待2MSL的意义

如果不等待会怎样？

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

- **1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端**
- **1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达**

这就是等待 2MSL 的意义。

### 为什么是四次挥手而不是三次？

因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。

### 同时关闭会怎样？

如果客户端和服务端同时发送 FIN ，状态会如何变化？如图所示:



<img src="https://pic3.zhimg.com/80/v2-5420c5865277deb412a7908957be7076_720w.jpg" alt="img" style="zoom: 67%;" />



## 004: 说说半连接队列和 SYN Flood 攻击的关系

三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：**半连接队列**和**全连接队列**，即**SYN队列**和**ACCEPT队列**。

### 半连接队列（SYN队列）

当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了**SYN队列**，也就是**半连接队列**。

### 全连接队列（ACCEPT队列）

当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是**全连接队列(Accept Queue)**。

### SYN Flood 攻击原理

SYN Flood 属于典型的 DoS/DDoS (Denial of Service/Distributed Denial of Service)攻击。服务器端的资源分配是在**二次握手**时分配的，而**客户端的资源是在完成三次握手时分配**的，所以服务器容易受到SYN洪泛攻击。

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:

1. 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个**半连接队列**，无法处理正常的请求。
2. 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```
netstat -n -p TCP | grep SYN_RECV
```

### 如何应对 SYN Flood 攻击？

1. 增加 SYN 连接，也就是**增加半连接队列的容量，增加最大半连接数。**
2. **减少 SYN + ACK 重传次数**，避免大量的超时重发。
3. 利用 **SYN Cookie 技术**，在服务端接收到SYN后**不立即分配连接资源**，而是**根据这个SYN计算出一个Cookie**，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，**服务端验证 Cookie 合法之后才分配连接资源。**
4. 过滤网关防护

## 005: 介绍一下 TCP 报文头部的字段

<img src="http://47.98.159.95/my_blog/tcp/005.jpg" style="zoom:67%;" />

### 源端口、目标端口

如何唯一标识一个连接？

答案是 **TCP 连接的四元组**——**源 IP、源端口**、**目标 IP 和目标端口**。

那 TCP 报文怎么没有源 IP 和目标 IP 呢？**这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。**

### 序列号

即Sequence number, 指的是本报文段第一个字节的序列号。

从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。

序列号在 TCP 通信的过程中有两个作用: 

1. 在 SYN 报文中交换彼此的初始序列号。
2. 保证数据包按正确的顺序组装。

### ISN

即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。

ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？

如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。

而动态增长的 ISN 大大提高了猜测 ISN 的难度。

> 补充阅读：
>
> 比如：假设C和S正在进行TCP通信，X是破坏者，可以预测TCP ISN。X可能的攻击包括：
>
> 一.身份仿冒
>
> 攻击过程简述如下：
>
> 1）X首先对C进行攻击（比如Syn Flood），导致C不可用。
>
> 2）然后X仿冒C的地址对S发起连接请求。
>
> 3）S对C进行回应，附带ISN。注意：这个报文X是收不到的。
>
> 4）X可以预测ISN，可以按预测的ISN直接给S回应确认，这时S误认为已经和C建立了连接。
>
> 5）X这时就可以仿冒C的地址，发送恶意指令给S，S会认为这是C下发的指令，被欺骗执行，攻击生效。
>
> ![img](http://5b0988e595225.cdn.sohucs.com/images/20180910/2d469155623d4b859014f22b4f5b8836.png)
>
> 这个攻击过程中，X不需要获得S的任何报文，就可以对S下发数据，这些数据可能是恶意指令，从而达到攻击的目的。
>
> 二、DoS攻击
>
> 因为X可以预测C和S的序列号，就可以在C和S通信的过程中，假冒一方的IP地址，频繁抢先一步发送错误的报文：
>
> 1）发送序列号正确的ack报文，导致很多正确的报文被丢弃，TCP连接看上起正常，但是因为很多正确的报文被丢弃，实际处于拒绝服务状态。
>
> 2）发送序列号正确的fin报文，导致TCP连接关闭，系统处于拒绝服务状态。
>
> 三、信息投毒
>
> 和DoS攻击类似，但属于更高级别的攻击。因为X可以预测ISN，就可以在通信过程中，假冒其中一方，使用正确的序列号抢先发送非法内容，而正确的报文在到达时被认为是重复的无效报文被丢弃。
>
> 这种攻击需要对双方通信协议的内容有一定的了解，塞入的报文符合原来通信规格要求，被认为是合法报文进行了处理。

### 确认号

即ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，**小于ACK**的所有字节已经全部收到。

### 标记位

常见的标记位有SYN,ACK,FIN,RST,PSH。

SYN 和 ACK 已经在上文说过，后三个解释如下: FIN： 即 Finish，表示发送方准备断开连接。

RST：即 Reset，用来强制断开连接。

PSH： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。

### 窗口大小

占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。

### 校验和

占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。

### 可选项

常用的可选项有以下几个:

\- TimeStamp: TCP 时间戳，后面详细介绍。 -

MSS: 指的是 TCP 允许的从对方接收的最大报文段。

\- SACK: 选择确认选项。

\- Window Scale： 窗口缩放选项。 

## 006: 说说 TCP 快速打开的原理(TFO)

第一节讲了 TCP 三次握手，可能有人会说，每次都三次握手好麻烦呀！能不能优化一点？

可以啊。今天来说说这个优化后的 TCP 握手流程，也就是 TCP 快速打开(**TCP Fast Open**, 即**TFO**)的原理。

优化的过程是这样的，还记得我们说 SYN Flood 攻击时提到的 SYN Cookie 吗？**这个 Cookie 可不是浏览器的Cookie, 用它同样可以实现 TFO。**

### TFO 流程

### 首轮三次握手

首先客户端发送`SYN`给服务端，服务端接收到。

注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个`SYN Cookie`, 将这个`Cookie`放到 TCP 报文的 `Fast Open`选项中，然后才给客户端返回。

客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。

首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！

### 后面的三次握手

在后面的三次握手中，客户端会将之前缓存的 `Cookie`、`SYN` 和`HTTP请求`(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回`SYN + ACK`。

重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。

当然，客户端的`ACK`还得正常传过来，不然怎么叫三次握手嘛。

流程如下:



<img src="https://pic1.zhimg.com/80/v2-8400842fde097a15139515f3887c0e0c_720w.jpg" alt="img" style="zoom:67%;" />



注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。

### TFO 的优势

TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了**1 个RTT**(`Round-Trip Time，往返时延`)的时间**提前进行数据传输**，积累起来还是一个比较大的优势。

## 007: 能不能说说TCP报文中时间戳的作用？

timestamp是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:

```text
kind(1 字节) + length(1 字节) + info(8 个字节)
```

其中 kind = 8， length = 10， info 有两部分构成: **timestamp**和**timestamp echo**，各占 4 个字节。

那么这些字段都是干嘛的呢？它们用来解决那些问题？

接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题: 

- 计算往返时延 RTT(Round-Trip Time) 
- 防止序列号的回绕问题

### 计算往返时延 RTT

在没有时间戳的时候，计算 RTT 会遇到的问题如下图所示:



<img src="https://pic4.zhimg.com/80/v2-56464c07cd5592cfa97bbc661cdb9233_720w.jpg" alt="img" style="zoom: 150%;" />



如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大，开始时间应该采用第二次的；

如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小，开始时间应该采用第一次发包的。

实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。

那这个时候引入时间戳就很好的解决了这个问题。

比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么：

- **step 1:** a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的内核时刻 ta1。
- **step 2:** b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb, timestamp echo字段为从 s1 报文中解析出来的 ta1。
- **step 3:** a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。

### 防止序列号回绕问题

现在我们来模拟一下这个问题。

序列号的范围其实是在0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。 | 第几次发包 | 发送字节 | 对应序列号 | 状态| |-|-|-|-| |1|0 ~ 1| 0 ~ 1| 成功接收| |2|1 ~ 2| 1 ~ 2| 滞留在网络中| |3|2 ~ 3| 2 ~ 3| 成功接收| |4|3 ~ 4| 3 ~ 4| 成功接收| |5|4 ~ 5| 0 ~ 1| 成功接收，序列号从0开始| |6|5 ~ 6| 1 ~ 2| ？？？|

假设在第 6 次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为1 ~ 2的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕的问题。

那么用 timestamp 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。

## 008: TCP 的超时重传时间是如何计算的？

TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。

那么这个重传间隔是如何来计算的呢？

今天我们就来讨论一下这个问题。

这个重传间隔也叫做**超时重传时间**(Retransmission TimeOut, 简称RTO)，它的计算跟上一节提到的 RTT 密切相关。这里我们将介绍两种主要的方法，一个是经典方法，一个是标准方法。

### 经典方法

经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，没产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0):

```text
SRTT =  (α * SRTT) + ((1 - α) * RTT)
```

其中，α 是**平滑因子**，建议值是0.8，范围是0.8 ~ 0.9。

拿到 SRTT，我们就可以计算 RTO 的值了:

```text
RTO = min(ubound, max(lbound, β * SRTT))
```

β 是加权因子，一般为1.3 ~ 2.0， **lbound** 是下界，**ubound** 是上界。

其实这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是0.8 ~ 0.9, RTT 对于 RTO 的影响太小。

### 标准方法

为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫Jacobson / Karels 算法。

一共有三步。

**第一步**: 计算SRTT，公式如下:

```text
SRTT = (1 - α) * SRTT + α * RTT
```

注意这个时候的 α跟经典方法中的α取值不一样了，建议值是1/8，也就是0.125。

**第二步**: 计算RTTVAR(round-trip time variation)这个中间变量。

```text
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
```

β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。

**第三步**: 计算最终的RTO:

```text
RTO = µ * SRTT + ∂ * RTTVAR
```

µ建议值取1, ∂建议值取4。

这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切。

## 009: 能不能说一说 TCP 的流量控制？

对于发送端和接收端而言，TCP 需要把发送的数据放到**发送缓存区**, 将接收的数据放到**接收缓存区**。

而流量控制索要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。

要具体理解流量控制，首先需要了解滑动窗口的概念。

### TCP 滑动窗口

TCP 滑动窗口分为两种: **发送窗口**和**接收窗口**。

### 发送窗口

发送端的滑动窗口结构如下:



<img src="https://pic2.zhimg.com/80/v2-3cd9e36dfbad543a00dba1a430708af5_720w.jpg" alt="img" style="zoom:67%;" />



其中包含四大部分: - 已发送且已确认 - 已发送但未确认 - 未发送但可以发送 - 未发送也不可以发送

其中有一些重要的概念，我标注在图中:



<img src="https://pic3.zhimg.com/80/v2-694b4932025a64c2ba9ca0a02c8810ce_720w.jpg" alt="img" style="zoom:67%;" />



发送窗口就是图中被框住的范围。SND 即send, WND 即window, UNA 即unacknowledged, 表示未被确认，NXT 即next, 表示下一个发送的位置。

### 接收窗口

接收端的窗口结构如下:



<img src="https://pic2.zhimg.com/80/v2-eb29637c332d0920aacf383107930215_720w.jpg" alt="img" style="zoom: 67%;" />



REV 即 receive，NXT 表示下一个接收的位置，WND 表示接收窗口大小。

### 流量控制过程

这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。

首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。

假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。

现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。

注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。

因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。

此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时**发送窗口**缩小为 140 个字节。

这也就是**流量控制**的过程。尽管回合再多，整个控制的过程和原理是一样的。

## 010: 能不能说说 TCP 的拥塞控制？

上一节所说的**流量控制**发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。

对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态: - 拥塞窗口（Congestion Window，cwnd） - 慢启动阈值（Slow Start Threshold，ssthresh）

涉及到的算法有这几个: - 慢启动 - 拥塞避免 - 快速重传和快速恢复

接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起。

### 拥塞窗口

拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。

那么之前介绍了接收窗口的概念，两者有什么区别呢？ - 接收窗口(rwnd)是接收端给的限制 - 拥塞窗口(cwnd)是发送端的限制

限制谁呢？

限制的是发送窗口的大小。

有了这两个窗口，如何来计算发送窗口？

```text
发送窗口大小 = min(rwnd, cwnd)
```

取两者的较小值。而拥塞控制，就是来控制cwnd的变化。

### 慢启动

刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。

因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:

- 首先，三次握手，双方宣告自己的接收窗口大小
- 双方初始化自己的**拥塞窗口**(cwnd)大小
- 在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。

难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做**慢启动阈值**，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！

在到达阈值后，如何来控制 cwnd 的大小呢？

这就是拥塞避免做的事情了。

### 拥塞避免

原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: **1 / cwnd**。那你仔细算算，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。

也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。

当然，**慢启动**和**拥塞避免**是一起作用的，是一体的。

### 快速重传和快速恢复

### 快速重传

在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。

比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。

这就是**快速重传**，它解决的是**是否需要重传**的问题。

### 选择性重传

那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？

当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。

在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做**选择性重传(SACK，Selective Acknowledgment)**，它解决的是**如何重传**的问题。

### 快速恢复

当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入**快速恢复**阶段。

在这个阶段，发送端如下改变： - 拥塞阈值降低为 cwnd 的一半 - cwnd 的大小变为拥塞阈值 - cwnd 线性增加

以上就是 TCP 拥塞控制的经典算法: **慢启动**、**拥塞避免**、**快速重传和快速恢复**。

## 011: 能不能说说 Nagle 算法和延迟确认？

### Nagle 算法

试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。

而避免小包的频繁发送，这就是 Nagle 算法要做的事情。

具体来说，Nagle 算法的规则如下: - 当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送 - 后面发送满足下面条件之一就可以发了: - 数据包大小达到最大段大小(Max Segment Size, 即 MSS) - 之前所有包的 ACK 都已接收到

### 延迟确认

试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？

**延迟确认**(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。

不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复: - 接收到了大于一个 frame 的报文，且需要调整窗口大小 - TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置） - 发现了乱序包

### 两者一起使用会怎样？

前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。

## 012. 如何理解 TCP 的 keep-alive？

大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。

试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。

这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。

在 Linux 下，可以这样查看相关的配置:

```text
sudo sysctl -a | grep keepalive

// 每隔 7200 s 检测一次
net.ipv4.tcp_keepalive_time = 7200
// 一次最多重传 9 个包
net.ipv4.tcp_keepalive_probes = 9
// 每个包的间隔重传间隔 75 s
net.ipv4.tcp_keepalive_intvl = 75
```

不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？

站在应用的角度: - 7200s 也就是两个小时检测一次，时间太长 - 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接

因此是一个比较尴尬的设计。

## 013. 总结：

《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。

![img](https://pic2.zhimg.com/80/v2-7c402fde8210519feb8f65d41410c205_720w.jpg)

以后面试官再问你三次握手和四次挥手，直接把这一篇文章丢给他就可以了，他想问的都在这里。

参考：《TCP/IP详解 卷1:协议》

参考资料:

[《web协议详解与抓包实战——陶辉》](https://link.zhihu.com/?target=https%3A//time.geekbang.org/course/intro/175)

[《趣谈网络协议》——刘超](https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/article/0%3Fcid%3D85)

[掘金小册《深入理解 TCP 协议: 从原理到实战》](https://link.zhihu.com/?target=https%3A//juejin.im/book/5c70dbbe51882562046911bc)

[关于 BBR 拥塞控制算法论文](https://link.zhihu.com/?target=https%3A//queue.acm.org/detail.cfm%3Fid%3D3022184)
