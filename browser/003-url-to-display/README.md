
# 003-从输入一个URL到在浏览器上显示的全过程

<motto></motto>

**全流程如下：**

1. 判断URL，触发 window 对象的 beforeunload 事件
2. 把URL请求转发至网络进程
3. 检查强缓存；若强缓存过期，则进行协商缓存
4. DNS 解析
5. 建立 TCP 连接
6. TLS 连接建立
7. 构建 HTTP 请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中
8. 向服务器发送构建的请求信息
9. 响应（重定向是，301/302，Location）
10. 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度Connection:Keep-Alive
11. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染
12. 准备渲染进程（同一站点可以共用）
    1. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
    2. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
    3. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页
13. 提交文档（网络进程将 HTML 文档提交给渲染进程）
14. 渲染阶段
       1. 构建 DOM 树（HTM 解析器），字节流 —> 字符流 —> Tokens —> 节点 —> DOM树

       2. 解析过程中遇到图片、样式表、js文件，启动下载

       3. 样式计算（或者叫构建 CSSOM）
          - 把CSS转换为浏览器能理解的 stylesheets 结构
          - 转换样式表中的属性值，使其标准化
          - 计算 DOM 树的每个节点的具体样式（继承，层叠）
          - 最终形成 computedStyle
       4. 页面布局阶段（计算几何位置信息，生成 Render Tree）
          - 创建渲染树（只包含可见节点，不可见节点包括：a）`script`,`meta`这样本身不可见的标签。b)被css 隐藏的节点，如`display: none`） —> DOM + ComputedStyle
          - 坐标计算
          - 渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，而图层在GPU中， `transform` 是不会触发 repaint 的，这一点非常类似3D绘图功能，最终这些使用 `transform` 的图层都会由独立的合成进程进行处理。
       5. JS解析
          1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
          2. HTML解析器遇到**没有async和defer的script时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write() 把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
          3. 当解析器遇到设置了**async**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素
          4. 当文档完成解析，document.readState 变成 interactive
          5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用document.write()
          6. 浏览器**在Document对象上触发 DOMContentLoaded 事件**
          7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，**document.readState** 变为 **complete**，**window**触发 **load** 事件
   17. 分层 —> 图层树 Layer Tree
   18. 绘制（绘制指令有很多的小指令构成）
   19. 分块（合成线程将图层划分为图块）
   20. 光栅化和合成
       - 栅格化（将图块转换为位图）
       - 栅格化线程池
       - 位图存到GPU
   21. 所有图块被光栅化后 —> 合成线程生成绘制指令 —> 将命令提交给浏览器进程
   22. 浏览器进程 —> display



