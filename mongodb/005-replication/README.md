# 005 - 数据复制

## 1. 概念

好处：

* 高可用性
* 数据安全
* 分流/分工

启动多个 Mongod 进程，并且在每个进程中对同一份数据保存多个备份，那么多个 Mongod 进程组成一个集群，叫做 `复制集` 。

在复制集中，每一个 Mongod 的进程都叫做 `节点` 。

不同的节点有不同的分工，每个复制集中都会有一个主节点，主节点负责处理所有客户发生的关于 `写` 数据的请求（**更新**或者是**新增**）。

副节点会不停地从主节点上进行数据的备份和数据更新。

客户的读取请求在默认的情况下也仍然是由主节点进行处理的，但是可以进行选项配置静儿也可以从复制集中的副节点读取数据（但副节点的数据可能与主节点不同）。

### 小总结：

* 主节点负责处理所有的写入请求
* 主节点（默认）和副节点都可以处理读取请求
* 副节点从主节点（或者符合条件的副节点）处复制数据
* 每个节点都会向其他节点发送心跳请求
* 每隔2秒发送一次，超过10秒则请求超时（默认）
* 复制集中最多可以有50个节点（防止心跳请求太多）

## 2. 复制集选举Querum

复制集主节点由选举算法挑选出来。

* 候选节点发起选举，每个节点投票给比自己更同步的节点
* 得到超过半数选票的候选节点会当选为主节点
* 复制集中最多可以有7个投票节点

### 触发选举的事件

* 主节点与副节点之间的心跳请求超时
* 复制集初始化
* 新节点加入复制集(也可以是之前坏掉的节点加入，也会触发)

## 3. 投票机

* 没有数据
* 可以投票
* 不能成为主节点

## 4. 数据备份过程

1. 初始同步（数据库，集合，索引，文档）
2. 写库记录同步（local.oplog.rs）

   - 写库日志中的记录可以被重复使用
   - 多个线程分批次使用日志记录
   - 写库日志的大小和文档大小不一定成正比

## 5. 命令

``` js
# 创建完mongo进程后，初始化复制集
rs.initiate({
    id: "myset",
    members: [{
        _id: 0,
        host: "mongol:27017"
    }, {
        _id: 1,
        host: "mongo2:27018"
    }, {
        _id: 2,
        host: "mongo3:27019"
    }]
})

# 查看复制集状态
rs.status()
```

















